#!/bin/bash


echo "loading: .syslib/syscore"


# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

iotech_hdr () {
   sleep 4
   clear
   echo ""
   toilet -t -f smblock --filter border:metal " iotech.systems SIMeng "
   echo ""
   return 0
}

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

del_previous_install () {
   echo_call

   store_gtoken

   echo_dbg "CONF_INSTALL_PATH: $CONF_INSTALL_PATH"
   rm -r "$CONF_INSTALL_PATH" || echo_neg "UNABLE_TO_REMOVE: ${CONF_INSTALL_PATH}"
   if [ -d "$CONF_INSTALL_PATH" ]; then
      echo_neg "UNABLE_TO_REMOVE: $CONF_INSTALL_PATH"
   else
      echo_pos "REMOVED: $CONF_INSTALL_PATH"
   fi


   echo_call_end
   return 0

}


store_gtoken () {
   echo_call

   local token_file
   token_file="${CONF_INSTALL_PATH}/custom/token"
   echo_dbg "loading: ${token_file}"
   if [ -a "${token_file}" ]; then
      GBL_TMP_GTOKEN=$(cat $token_file)
      echo_dbg "GBL_TMP_GTOKEN: $GBL_TMP_GTOKEN"
   fi

   echo_call_end
   return 0

}


# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

run_preinstall () {
   echo_call

   echo_dbg "CONF_INSTALL_PATH: $CONF_INSTALL_PATH"

   local error_code
   error_code=-1

   if [ -d "$CONF_INSTALL_PATH" ]; then
      echo_warning "[ Previous installation detected ]"
      read -r -p "${TAB8}Reinstall? (y/n): " ans
      case "$ans" in
         "Y" | "y")
            del_previous_install
            error_code=$?
            if (( err_code == 0 )); then
               run_install
            else
               echo_neg "[ del_previous_install: ${error_code} ]"
            fi
         ;;
         *)
            exit 0
         ;;
      esac
      exit 0
   else
      read -r -p "Press (y/Y) to continue: " ans
      case "$ans" in
         "Y" | "y")
            run_install
         ;;
         *)
            exit 0
         ;;
      esac
      mkdir "$CONF_INSTALL_PATH" || true && echo "DIR-MADE: $CONF_INSTALL_PATH"
   fi

   echo_call_end
   return 0

}

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

run_install () {
   echo_call

   # create sims folder
   mkdir "${CONF_INSTALL_PATH}/simslib" -p
   mkdir "${CONF_INSTALL_PATH}/github" -p
   mkdir "${CONF_INSTALL_PATH}/logs" -p
   mkdir "${CONF_INSTALL_PATH}/data" -p
   mkdir "${CONF_INSTALL_PATH}/pyvenvs" -p
   mkdir "${CONF_INSTALL_PATH}/custom" -p
   touch "${CONF_INSTALL_PATH}/custom/gtoken"
   if [ -n "${GBL_TMP_GTOKEN}" ]; then
      echo "${GBL_TMP_GTOKEN}" > "${CONF_INSTALL_PATH}/custom/gtoken"
   fi
   touch "${CONF_INSTALL_PATH}/custom/repos"
   chown nobody:nogroup -R "${CONF_INSTALL_PATH}"
   chmod -R 777 "${CONF_INSTALL_PATH}"
   # -- -- --
   gry_block
   ls "${CONF_INSTALL_PATH}" -la
   gry_block_end
   # -- -- --
   echo "OK" > "${CONF_INSTALL_PATH}/logs/pre-install-msg"

   echo_call_end
   return 0

}

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

check_logs () {
   echo_call
   # -- -- --

   local log_file_pyvenv
   log_file_pyvenv=".logs/py3venv-run"

   if [ ! -f "$log_file_pyvenv" ]; then
      echo_pnf "$log_file_pyvenv"
      echo_call_end
      return 1
   fi

   local fbuff
   fbuff=$(cat "$log_file_pyvenv")
   if [[ "$fbuff" -ne  "PYTHON3-VENV-OK" ]]; then
      echo_dbg "BAD_PY3_VENV_RUN: $buff"
      return 2
   fi

   echo_dbg "PY3_VENV_RUN: $fbuff"
   echo_pos "$fbuff"

   echo_call_end
   return 0

}

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

set_custom_dpad () {
   echo_call
   # -- -- --

   local cust_dpath
   cust_dpath=$(cat conf/custom-dpath)
   echo_dbg "checking cust_dpath: $cust_dpath"

   if [ ! -d "$cust_dpath" ]; then
      echo_pnf "$cust_dpath"
      return 1
   fi

   echo_pok "$cust_dpath"
   GLB_CUST_DPATH="$cust_dpath"

   echo_call_end
   return 0

}

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

set_gtoken () {
   echo_call
   # -- -- --

   local gtoken_file
   gtoken_file="$GLB_CUST_DPATH/gtoken"
   echo_dbg "gtoken-fpath: $gtoken_file"
   if [ ! -f "$gtoken_file" ]; then
      echo_pnf "$gtoken_file"
      exit 1
   fi

   echo_pos "$gtoken_file"
   GTOKEN=$(cat "$gtoken_file")
   echo_dbg "GTOKEN: $GTOKEN"

   echo_call_end
   return 0

}

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

set_github_dpath () {
   echo_call
   # -- -- --

   local github_root
   github_root="$GLB_CUST_DPATH/github-root"
   echo_dbg "checking github_root: $github_root"

   if [ ! -f "$github_root" ]; then
      echo_pnf "$github_root"
      exit 1
   fi

   echo_pos "$github_root"
   GLB_GITHUB_DPATH=$(cat "$github_root")
   echo_dbg "GLB_GITHUB_DPATH: $GLB_GITHUB_DPATH"

   if [ ! -d "$GLB_GITHUB_DPATH" ]; then
      echo_pnf "$GLB_GITHUB_DPATH"
      return 1
   fi

   echo_pok "$GLB_GITHUB_DPATH"

   echo_call_end
   return 0

}

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

check_custom_dependencies () {   
   echo_call
   # -- -- --

   # -- -- check custom folder -- --
   local CUST_DPATH
   CUST_DPATH=$(cat conf/custom-dpath)
   echo_dbg "CUST_DPATH: $CUST_DPATH"
   if [ ! -d "$CUST_DPATH" ]; then
      echo_pnf $CUST_DPATH
      exit 1
   else
      echo_pos "$CUST_DPATH"
   fi

   # -- check gtoken file --
   local gtoken_file
   gtoken_file="$CUST_DPATH/gtoken"
   echo_dbg "gtoken-fpath: $gtoken_file"
   if [ ! -f "$gtoken_file" ]; then
      echo_pnf "$gtoken_file"
      exit 1
   else
      echo_pos "$gtoken_file"
      GTOKEN=$(cat "$gtoken_file")
      echo_dbg "GTOKEN: $GTOKEN"
   fi

   # -- check custom repos file --
   local custom_repos_file
   custom_repos_file="$CUST_DPATH/custom-repos"
   echo_dbg "custom-repos-fpath: $custom_repos_file"
   if [ ! -f "$custom_repos_file" ]; then
      echo_pnf "$custom_repos_file"
      exit 1
   else 
      echo_pos "$custom_repos_file"
      source "$custom_repos_file"
      for repo in ${GH_CUSTOM_REPOS[@]}; do
         echo_dbg "repo: $repo"
      done
   fi

   # -- check github root folder --
   local github_root_fld
   github_root_fld="$CUST_DPATH/github-root"
   echo_dbg "github_root_fld: $github_root_fld"
   if [ ! -f "$github_root_fld" ]; then
      echo_pnf "$github_root_fld"
      exit 1
   else 
      echo_pos "$github_root_fld"
      GHROOT=$(cat "$github_root_fld")
      echo_dbg "GHROOT: $GHROOT"
      if [ ! -d "$GHROOT" ]; then
         echo_pnf "$GHROOT"
         exit 1
      else
         echo_pos "$GHROOT"
      fi
   fi

   echo_call_end
   return 0

}


setup_py_venv () {
   echo_call

   echo_dbg "CWD: $(pwd)"
   echo_dbg "installing pyvenv: $py_ver in ${CONF_INSTALL_PATH}/pyvenv/py3.13"
   python3 -m venv "${CONF_INSTALL_PATH}/pyvenv/py3.13"

   echo_call_end
   return 0

}


pyvenv_run_pip3 () {
   echo_call

   local buff0
   buff0=$(which python3)
   echo_dbg "$buff0"

   local buff1
   buff1=$(which pip3)
   echo_dbg "$buff1"

   local venv_path
   venv_path="${CONF_INSTALL_PATH}/pyvenv/py3.13"
   [[ ! -d "${venv_path}"  ]] && echo_pnf "${venv_path}" && exit 1


   local source_err
   source "${venv_path}/bin/activate"
   source_err=$?
   if (( source_err != 0 )); then
      echo_neg "source_err: $source_err"
      return 2
   fi

   echo_dbg "which-pip3: $(which pip3)"

   gry_block
   pip3 install -r "$PIP_INSTALL_FLD" &> /dev/null
   echo ""
   pip3 list
   gry_block_end

   echo_dbg "which-pip3: $(which pip3)"

   echo_call_end
   return 0

}


verify_pyvenv () {
   echo_call

   local venv_path
   venv_path="${CONF_INSTALL_PATH}/pyvenv/py3.13"
   [[ ! -d "${venv_path}"  ]] && echo_pnf "${venv_path}" && exit 1


   local source_err
   source "${venv_path}/bin/activate"
   source_err=$?
   if (( source_err != 0 )); then
      echo_neg "source_err: $source_err"
      return 2
   fi

   local buff0
   buff0=$(whereis python3)
   echo_dbg "WHEREIS ( python3 ):"
   for l in $buff0; do
      echo_dbg "  -> $l"
   done

   local buff1
   buff1=$(which python3)
   echo_dbg "WHICH ( python3 ):"
   echo_dbg "  -> $buff1"

   echo_call_end
   return 0

}


create_py_venv () {
   echo_call
   # -- -- -

   local py_version
   py_version=$1

   local py_venv_fld
   py_venv_fld=$2

   echo_dbg "cwd: $(pwd)"
   echo_dbg "installing py_venv: $py_version / $py_venv_fld"


   local py_ver_err_code
   is_py_ver_installed "$py_version"
   py_ver_err_code=$?
   if (( py_ver_err_code != 0 )); then
      echo_neg "Your system is missing needed version of PYTHON / $py_version"
      echo_dbg "Please install needed version of PYTHON on your system: $py_version"
      exit 1
   else 
      echo_pos "Good SYSTEM python version found: $py_version"
   fi

   local py_venv_fld_path
   py_venv_fld_path="$PY_VENVS_ROOT/$py_venv_fld"
   if [[ -d "$py_venv_fld_path" ]]; then 
      echo_pos "[[ VENV_FOLDER_FOUND: $py_venv_fld_path ]]"
      local err_code
      check_venv_py_ver "$py_venv_fld_path"
      err_code=$?
      if (( err_code != 0 )); then
         echo_dbg "[ REINSTALLING VENV: $py_version ]"
         setup_py_venv "$py_version" "$py_venv_fld_path"
         check_venv_py_ver "$py_venv_fld_path"
      fi
   else 
      echo_neg "[[ VENV_FOLDER_NOT_FOUND ]]"
      mkdir "$py_venv_fld_path" -p
      setup_py_venv "$py_version" "$py_venv_fld_path"
      check_venv_py_ver "$py_venv_fld_path"
   fi

   echo_call_end
   return 0

}

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

clone_repo () {
   echo_call

   if [ -z "$GLB_GTOKEN" ]; then
      echo_neg "GLB_GTOKEN_IS_EMPTY"
      exit 1
   fi

   local gurl
   gurl="$1"
   echo_dbg "gurl: $gurl"

   # test url for keyword TOKEN   
   if [[ "$gurl" =~ .*TOKEN*  ]]; then
      echo_dbg "template: $gurl"
   else 
      local turl
      turl="https://TOKEN@github.com/iotech-systems/ue-core.git"
      echo_neg "NO_'TOKEN'_IN_REPO_URL: $gurl"
      echo_info "You must add keyword TOKEN to repo URL\n    [ CORRECT-FORMAT: $turl ]"
      echo_info "You must fix this and restart the process!"
      exit 1
   fi

   local _repo_url
   _repo_url=$(echo "$gurl" | sed "s/TOKEN/$GLB_GTOKEN/")

   echo_dbg "REPO-URL: ${_repo_url}"
   echo_dbg "CWD: $(pwd)"

   # shellcheck disable=SC2001
   local err_code
   gry_block
   git clone "${_repo_url}"
   err_code=$?
   gry_block_end

   if (( err_code == 0 )); then
      echo_pos "[ ERR: $err_code | OK_CLONING_REPO: $_repo_url ]"
   elif (( err_code != 0 )) && (( err_code == 128 )); then
      echo_warning "[ ERR: $err_code | ERROR_CLONING_REPO: $_repo_url ]"
   else
      echo_neg "[ ERR: $err_code | ERROR_CLONING_REPO: $_repo_url ]"
   fi

   echo_call_end
   return 0

}

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

clone_default_repos () {
   echo_call

   echo_dbg "GBL_INSTALL_FLD: ${GBL_INSTALL_FLD}"
   echo_dbg "CWD: $(pwd)"
   cd "${CONF_INSTALL_PATH}/github"
   echo_dbg "CWD: $(pwd)"

   echo ""
   echo_pos "[ INSTALLING_CORE_REPOS ]"
   for repo_url in ${GH_REPOS[@]}; do
      clone_repo "${repo_url}"
   done

   echo_call_end
   return 0

}

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

clone_cust_repos () {
   echo_call
   # -- -- --
   
   echo_dbg "   gtoken: $1"
   echo_dbg "   cwd: $(pwd)"

   echo "" && echo ""
   echo_pos "[ INSTALLING_CUSTOM_REPOS ]"
   for repo in ${GH_CUSTOM_REPOS[@]}; do
      clone_repo $1 "$repo"
   done

   echo_call_end
   return 0

}


sync_repo () {
   echo_call

   echo "   token: $1"
   echo "   url: $2"
   echo "   cwd: $(pwd)"

   for fl in . ; do
      echo "f: $fl"
   done

   echo_call_end
   return 0

}


check_sys_py () {
   echo_call

   local buff0
   buff0=$(whereis python3)
   echo_dbg "WHEREIS ( python3 ):"
   for l in $buff0; do
      echo_dbg "  -> $l"
   done

   local buff1
   buff1=$(which python3)
   echo_dbg "WHICH ( python3 ):"
   echo_dbg "  -> $buff1"

   local return_val
   local buff_pyver
   buff_pyver=$(python3 --version)
   echo_dbg "$buff_pyver"
   if [[ "${buff_pyver,,}" =~ "python 3.13."  ]]; then
      echo_pos "[ Good python version found: ${buff_pyver} ]"
      return_val=0
   else
      echo_neg "[ System has a wrong python version installed! | ${buff_pyver} ]"
      return_val=1
   fi

   echo_call_end
   return $return_val

}


check_custom_folder () {
   echo_call

   local custom_folder
   custom_folder="${CONF_INSTALL_PATH}/custom"
   if [ ! -d "${custom_folder}" ]; then
      echo_pnf "${custom_folder}"
      exit 1
   else
      echo_pok "${custom_folder}"
      gry_block
      ls "${custom_folder}" -la
      gry_block_end
   fi

   local token_file
   token_file="${custom_folder}/gtoken"
   echo_dbg "checking: ${token_file}"
   if [[ ! -a "${token_file}" ]]; then
      echo_pnf "${token_file}" && echo ""
      echo_info "Please create [ ${token_file} ] file with github token."
      exit 1
   fi

   GLB_GTOKEN=$(cat "${token_file}")
   echo_dbg "GLB_GTOKEN: $GLB_GTOKEN"
   if [ -z $GLB_GTOKEN ]; then
      echo_neg "GLB_GTOKEN_IS_EMPTY" && echo ""
      echo_info "Please insert github PAT token into [ ${token_file} ] file."
      exit 1
   fi

   local token_file
   repos_file="${custom_folder}/repos"
   echo_dbg "checking: ${repos_file}"
   if [[ ! -a "${repos_file}" ]]; then
      echo_pnf "${repos_file}" && echo ""
      echo_info "Please create [ ${repos_file} ] file."
      exit 1
   fi

   GLB_CUSTOM_REPOS=$(cat "${repos_file}")
   echo_dbg "GLB_CUSTOM_REPOS: $GLB_CUSTOM_REPOS"
   if [ -z $GLB_CUSTOM_REPOS ]; then
      echo_warning "GLB_GTOKEN_IS_EMPTY" && echo ""
   fi

   echo_call_end
   return 0

}


echo "load: OK"
